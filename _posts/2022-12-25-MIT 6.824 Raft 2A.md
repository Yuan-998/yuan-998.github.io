---
layout: post
title: Raft Algorithm, Beginner's Prespective
subtitle: Lab 2 Part A of MIT 6.824 Distributed Systems(Spring 2021)
tags: [Raft, Distributed Systems]
---

## Introduction
The raft algorithm itself has been discussed in great detail in this paper, *[In search of an Understandable Consensus Algorithm](https://raft.github.io/raft.pdf)* . 

Although the functionality and correctness of each part of raft algorithm are quite clear, how these parts are coupling with each other is a quite difficult part for me when solving this lab.

In this article I will try to explain my understanding of how the system parts are connected together in order to fullfill the leader election process.

## System Structure
Raft algorithm has mainly two parts, leader election and log replication.

For leader election, a node will start a new eleciton once it doesn't receive any RPC calls(vote request, append entry request or heartbeat) from the leader for a certain amount of time. So, each node should have a election timer and it will be reset if a node receive any kinds of RPC call from the leader.

For log replication, in this task, we only need to implement the heartbeat to stop the new elections from other server nodes. Combined with the principle of leader election, heartbeat should be sent to every server node repeatedly.

So, now we can arrive at a sketch of the system that there will be two `while` loops. One is for followers regarding leader election and the other is for the leader to send heartbeats. Thanks to `Go`, there is a very nice feature in `Go` that fits perfectly to this scenario and that is [`select`](https://go.dev/tour/concurrency/5). A typical use case of `select` is to control timeout. Let's take a look at the example below for handling tcp timeout. This should give you some enlightment.

```
func (n *node) waitForConnectPkt() {
	select {
	case <-n.connected:
		log.Println("Packet received")
	case <-time.After(time.Second * 5):
		log.Println("Packet timeout")
		n.conn.Close()
	}
}
```

### Workflow of a server node

If you have no problems of understanding the above part, we can discuss how each part of raft algorithm actually works. 

### Election Part

If a server node started a election, it first need to change some states of its own. Then the node should send requests to other server nodes to get them voting for it. After that, the node should collect replies and take further actions based on those.

[//]: # (TODO: more thoughts on this paragraph)
The key is that sending vote requests should be asynchronous. Why? First, if the candidate waits until all replies are available, a network partition or a crashed node can easily block the candidate forever. Second, remember that raft works on the idea of quorum. So, a candidate can claim to be the leader once it has votes from a quorum of nodes and ignore the replies of the rest nodes. So, the sending vote request can run in another thread and notify the main thread when it's done. 

So, how can the thread working on sending vote request notify the main thread when it's done? Thanks to `Go` again, there is something in `Go` called `Channel`. The channel can establish the communication unidirectionally. 

### Heartbeat Part

## Debugging

### Server Node Stuck in Vote Request