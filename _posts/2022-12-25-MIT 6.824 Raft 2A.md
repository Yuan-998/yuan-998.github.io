---
layout: post
title: Raft Algorithm, A Beginner's Prespective
subtitle: Lab 2 Part A of MIT 6.824 Distributed Systems(Spring 2021)
cover-img: "../assets/img/raft/lab2A.png"
tags: [Raft, Distributed Systems]
---

## Introduction
The raft algorithm itself has been discussed in great detail in this paper, *[In search of an Understandable Consensus Algorithm](https://raft.github.io/raft.pdf)* . 

Although the functionality and correctness of each part of raft algorithm are quite clear, how these parts are coupling with each other is a quite difficult part for me when solving this lab.

In this article I will try to explain my understanding of how the system parts are connected together in order to fullfill the leader election process.

## System Structure
Raft algorithm has mainly two parts, leader election and log replication.

For leader election, a node will start a new eleciton once it doesn't receive any RPC calls(vote request, append entry request or heartbeat) from the leader for a certain amount of time. So, each node should have a election timer and it will be reset if a node receive any kinds of RPC call from the leader.

For log replication, in this task, we only need to implement the heartbeat to stop the new elections from other server nodes. Combined with the principle of leader election, heartbeat should be sent to every server node repeatedly.

So, now we can arrive at a sketch of the system that there will be two `while` loops. One is for followers regarding leader election and the other is for the leader to send heartbeats. Thanks to `Go`, there is a very nice feature in `Go` that fits perfectly to this scenario and that is [`select`](https://go.dev/tour/concurrency/5). A typical use case of `select` is to control timeout. Let's take a look at the example below for handling tcp timeout. This should give you some enlightment.

```
func (n *node) waitForConnectPkt() {
	select {
	case <-n.connected:
		log.Println("Packet received")
	case <-time.After(time.Second * 5):
		log.Println("Packet timeout")
		n.conn.Close()
	}
}
```

### Workflow of a server node

If you have no problems of understanding the above part, we can discuss how each part of raft algorithm actually works. 

### Election Part

If a server node started a election, it first need to change some states of its own. Then the node should send requests to other server nodes to get them voting for it. After that, the node should collect replies and take further actions based on those.

[//]: # (TODO: more thoughts on this paragraph)
The key is that sending vote requests to each server node should be asynchronous. Why? Remember that raft works on the idea of quorum. So, a candidate can claim to be the leader once it has votes from a quorum of nodes and ignore the replies of the rest nodes to save some time. So, the sending vote request can run in individual thread and notify the main thread when it's done. 

So, how can the thread working on sending vote request notify the main thread when it's done? Thanks to `Go` again, there is something in `Go` called `Channel`. The channel can establish the communication unidirectionally. Of course, the candidate will stays in a loop to check whether it can claim to be the leader every time it receives a reply from the channel.

### Heartbeat Part

Once a new leader takes office, it will first send a heartbeat to notify all nodes that there is a new leader. After that, it keeps sending heartbeat periodically. This is relatively easy. However, for 2A, you don't actually need to implement everything mentioned in Figure 2 in the paper. Leader's term and leader's id should be enough.

## Debugging

This part will be about some bugs that I met.

### Server Node Stuck in Vote Request

As I mentioned above, the candidate will stay in a loop to check the replies from the followers. But it is possible that the RPC call failed or the follower doesn't vote for this candidate and the candidate cannot get enough votes to be the leader. So, we need to get the candidate be able to jump out the loop and continue. A counter is needed in order to track how many respones of the RPC calls has been received no matter the RPC call successed or not. In this way, we can get the candidate out of the loop when it doesn't get enough votes and start another election or becomes the follower.