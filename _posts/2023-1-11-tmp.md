---
layout: post
title: Temp
---

### 03
##### short variable declaration

In short varible declaration, there should be at least one new variable.
```
f, err := os.Open(infile)
// ...
f, err := os.Create(outfile) // compile error: no new variables
```
the correct one
<pre>
f, err := os.Open(infile)
// ...
f, err <b>=</b> os.Create(outfile) // compile error: no new variables
</pre>

##### pointer
In `Go`, it's safe to return a pointer to a local varible.
```
var p = f()

func f() *int {
	v := 1
	return &v
}
```

the pointer-based package, `flag` to handle the parameter in command line.

##### life span of a varible
The garbage collector in `Go` decides when a varible can be recycled based on whether this variable is still accessible with the pointer or reference. ???

##### stack or heap
In `Go`, the compiler decides where a varible is stored. Unlike `C/c++`, `var` and `new` don't have a say in this matter.

```
var global *int

func f() {
	var x int
	x = 1
	global = &x
}

func g() {
	y := new(int)
	*y = 1
}
```
varible `x` in function `f` is allocated on `heap`. `*y` in function `g` can be allocated on `stack` or on `heap`

### 04

##### tuple assignment
```
x, y = y, x
a[i], a[j] = a[j], a[i]
```

##### assignability


### 05

##### type
`type typeName underlyingTypeName`

```
// Package tempconv performs Celsius and Fahrenheit temperature computations.
package tempconv

import "fmt"

type Celsius float64    // 摄氏温度
type Fahrenheit float64 // 华氏温度

const (
	AbsoluteZeroC Celsius = -273.15 // 绝对零度
	FreezingC     Celsius = 0       // 结冰点温度
	BoilingC      Celsius = 100     // 沸水温度
)

func CToF(c Celsius) Fahrenheit { return Fahrenheit(c*9/5 + 32) }

func FToC(f Fahrenheit) Celsius { return Celsius((f - 32) * 5 / 9) }
```
`Celsius` and `Fahrenheit` in this example are **not** comparable.

`T(x)` to convert `x` to type `T`. Only when the underlying type are the same, can the conversion work.

```
func (c Celsius) String() string { return fmt.Sprintf("%g°C", c) }

c := FToC(212.0)
fmt.Println(c.String()) // "100°C"
fmt.Printf("%v\n", c)   // "100°C"; no need to call String explicitly
fmt.Printf("%s\n", c)   // "100°C"
fmt.Println(c)          // "100°C"
fmt.Printf("%g\n", c)   // "100"; does not call String
fmt.Println(float64(c)) // "100"; does not call String
```
when `func (c Celsius) String() string` is disabled.
```
fmt.Printf("%v\n", c)   // 100
fmt.Printf("%s\n", c)   // %!s(main.Celsius=100)
fmt.Println(c)          // 100
fmt.Printf("%g\n", c)   // 100
fmt.Println(float64(c)) // 100
```

### 06
##### name exportation
when a name (variable name, function name) begins with captical letter, then it's exported.